dat <- stri_split_fixed(dat, "\t", simplify = TRUE)
# set the column names
colnames(dat) <- col_names
# and then convert to a data frame
dat <- as_tibble(dat)
# now we need to replace the null values with NA
dat[dat == null_value] <- NA
# and convert to numeric
dat <- mutate_all(dat, as.numeric)
if (long_format) {
# let's make the data long format so we can
# easily group by subject or marker
dat <- dat %>%
pivot_longer(
cols = contains("_x") | contains("_y") | contains("_z"),
cols_vary = "slowest",
names_to = "marker",
values_to = "value"
) %>%
mutate(
subject = stri_replace_first_regex(marker, "^([AB])_.*", "$1"),
axis = stri_extract_last_regex(marker, "[xyz]$"),
marker = stri_replace_first_regex(
marker,
"^[AB]_([a-zA-Z_]+)_[xyz]$",
"$1"
)
)
# move axes to columns
dat <- dat %>%
pivot_wider(
names_from = axis,
values_from = value
)
dat$marker <- factor(dat$marker)
}
metadata <- list(
condition = cond,
frequency = freq,
marker_count = marker_count,
frame_count = frame_count,
marker_names = marker_names
)
# return the data and metadata
if (only_data) {
return(dat)
}
return(list(data = dat, metadata = metadata))
}
#' This function does a linear gap fill for a vector.
#'
#'   Only columns with at least 2 non-NA values will be gap filled.
#'
#'   Args:
#'     x (vector): The vector to gap fill.
#'
#'   Returns:
#'     The gap filled vector.
gap_fill_linear <- function(x) {
# get the indices of the NA values
na_indices <- which(is.na(x))
# get the indices of the non-NA values
non_na_indices <- which(!is.na(x))
if (length(na_indices) == 0) {
# if there are no NA values, just return the vector
return(x)
}
if (length(non_na_indices) < 2) {
# if there are less than 2 non-NA values, we can't do a linear interpolation
return(x)
}
# get the values of the non-NA indices
non_na_values <- x[non_na_indices]
# get the values of the NA indices
na_values <- x[na_indices]
# now we can do a linear interpolation
na_values <- approx(
x = non_na_indices,
y = non_na_values,
xout = na_indices,
method = "linear"
)$y
# now we can replace the NA values with the interpolated values
x[na_indices] <- na_values
# and return the vector
return(x)
}
#' This function reads a QTM QML label file.
#'
#'  Args:
#'   xmlpath (str): The path to the QML file.
#'
#' Returns:
#'  A dataframe with the trajectory names and colors.
read_trajectory_labels <- function(xmlpath) {
# load the XML file
xmlfile <- xmlParse(xmlpath)
# get the labels, which are in the following format:
# <QTM_Label_List_Ver_1.00>
#     <Trajectories>
#         <Trajectory>
#             <Name>A_head_top</Name>
#             <Color R="0" G="147" B="0"/>
#         </Trajectory>
#     </Trajectories>
# </QTM_Label_List_Ver_1.00>
# get the trajectory names
traj_names <- xpathSApply(xmlfile, "//Trajectory/Name", xmlValue)
# get the trajectory colors
traj_colors <- xpathSApply(xmlfile, "//Trajectory/Color", xmlAttrs)
# convert the colors to hex
traj_colors <- rgb(
as.numeric(traj_colors[1, ]),
as.numeric(traj_colors[2, ]),
as.numeric(traj_colors[3, ]),
alpha = 255,
maxColorValue = 255
)
# combine the names and colors into a data frame
traj_labels <- data.frame(
traj_names,
traj_colors,
stringsAsFactors = FALSE
)
return(traj_labels)
}
#load in a dataset
traj_data <- process_qtm_tsv("mocap_L1F2_open.tsv", only_data = TRUE)
# let's make the data long format so we can easily group by subject or marker
traj_data <- traj_data %>%
pivot_longer(
cols = contains("_x") | contains("_y") | contains("_z"),
cols_vary = "slowest",
names_to = "marker",
values_to = "value"
) %>%
mutate(
subject = stri_replace_first_regex(marker, "^(Lead|Follow)_.*", "$1"),
axis = stri_extract_last_regex(marker, "[xyz]$"),
marker = stri_replace_first_regex(marker, "^([a-zA-Z_]+)_[xyz]$", "$1")
) %>%
pivot_wider(
names_from = axis,
values_from = value
)
#you will need to think about this - for mirror game any marker will match the opposite side  -for some dance it might change, or you might have right hand on left shoulder. Head is rigid so any head marker should match just about fine.
#Type in the names of the markers you want to work with
markers_of_interest <- c(
"Lead_Hand_Right",
"Follow_Hand_Left"
)
#choose you comparisons by giving them the same number (if you have just two markers simply put the names and 1)
comp_pairs <- tibble(
marker = c("Lead_Hand_Right", "Follow_Hand_Left"),
comp_pair_id = c(1, 1)
)
# now we can select the markers of interest
selected_traj_data <- traj_data %>%
dplyr::filter(marker %in% markers_of_interest) %>%
left_join(comp_pairs, by = "marker")
#here is an example with just one axis
#setting max lag
max_lag <- 900 # 3 seconds
#select the comparison pair you want
sel_pairs = 1
#here is a loop testing for crosscorrelation acorss one axis
for (axis in c('x')){
#actual cross correlation
results <- ccf(
x = marker_data[marker_data$subject == "Lead", axis],
y = marker_data[marker_data$subject == "Follow", axis],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pairs,
axis = axis
)
xcor_results[[length(xcor_results) + 1]] <- results
}
#here is an example with just one axis
#setting max lag
max_lag <- 900 # 3 seconds
#select the comparison pair you want
sel_pairs = 1
#here is a loop testing for crosscorrelation acorss one axis
results <- list()
for (axis in c('x')){
#actual cross correlation
results <- ccf(
x = marker_data[marker_data$subject == "Lead", axis],
y = marker_data[marker_data$subject == "Follow", axis],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pairs,
axis = axis
)
xcor_results[[length(xcor_results) + 1]] <- results
}
sel_pair <- 1
window_size <- 600
max_lag <- 150
step_size <- 300
axes_of_interest = c("x", "y", "z")
for (window_start in seq(1, rowcount - window_size, step_size)) {
window_end <- window_start + window_size - 1
if (window_end > rowcount) {
window_end <- rowcount
}
results <- NULL
#function that runs cross correlation
results <- ccf(
x = subjA[window_start:window_end],
y = subjB[window_start:window_end],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pair,
axis = axis,
window_start = window_start,
window_end = window_end
)
xcor_results[[length(xcor_results) + 1]] <- results
}
results <- ccf(
x = marker_data[marker_data$subject == "Lead", "x"],
y = marker_data[marker_data$subject == "Follow", "x"],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results
#here is an example with just one axis
#setting max lag
max_lag <- 900 # 3 seconds
#select the comparison pair you want
sel_pairs = 1
results <- ccf(
x = marker_data[marker_data$subject == "Lead", "x"],
y = marker_data[marker_data$subject == "Follow", "x"],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pairs,
axis = axis
)
results
#plot results for each point
results %>%
ggplot(aes(x= lagv, y=acfv, color = axis)) +
geom_point() +
theme_minimal() +
facet_wrap(~comparison_pair) +
labs(
x = "Lag",
y = "Crosscorrelation",
title = "Crosscorrelation by lag"
)
sel_pair <- 1
window_size <- 600
max_lag <- 150
step_size <- 300
axes_of_interest = c("x", "y", "z")
for (window_start in seq(1, rowcount - window_size, step_size)) {
window_end <- window_start + window_size - 1
if (window_end > rowcount) {
window_end <- rowcount
}
results <- NULL
#function that runs cross correlation
results <- ccf(
x = subjA[window_start:window_end],
y = subjB[window_start:window_end],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pair,
axis = axis,
window_start = window_start,
window_end = window_end
)
xcor_results[[length(xcor_results) + 1]] <- results
}
axis <- "x"
axis_data <- data %>%
ungroup() %>%
dplyr:: select(subject, !!sym(axis))
subjA <- axis_data %>% filter(subject == "Lead") %>% pull(!!sym(axis))
subjB <- axis_data %>% filter(subject == "Follow") %>% pull(!!sym(axis))
rowcount <- length(subjA)
for (window_start in seq(1, rowcount - window_size, step_size)) {
window_end <- window_start + window_size - 1
if (window_end > rowcount) {
window_end <- rowcount
}
results <- NULL
#function that runs cross correlation
results <- ccf(
x = subjA[window_start:window_end],
y = subjB[window_start:window_end],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pair,
axis = axis,
window_start = window_start,
window_end = window_end
)
xcor_results[[length(xcor_results) + 1]] <- results
}
sel_pair <- 1
window_size <- 600
step_size <- 300
axes_of_interest = c("x", "y", "z")
axis <- "x"
# Initialize a list to store results across all windows
xcor_results <- list()
axis_data <- data %>%
ungroup() %>%
dplyr:: select(subject, !!sym(axis))
subjA <- axis_data %>% filter(subject == "Lead") %>% pull(!!sym(axis))
subjB <- axis_data %>% filter(subject == "Follow") %>% pull(!!sym(axis))
rowcount <- length(subjA)
for (window_start in seq(1, rowcount - window_size, step_size)) {
window_end <- window_start + window_size - 1
if (window_end > rowcount) {
window_end <- rowcount
}
results <- NULL
#function that runs cross correlation
results <- ccf(
x = subjA[window_start:window_end],
y = subjB[window_start:window_end],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pair,
axis = axis,
window_start = window_start,
window_end = window_end
)
xcor_results[[length(xcor_results) + 1]] <- results
}
# plot a heatmap for each condition, marker, axis
xcor_results %>%
ggplot(aes(x = lagv, y = window_start, fill = acfv)) +
geom_tile() +
scale_fill_distiller(palette = "Spectral") +
theme_minimal() +
facet_wrap(c(~comparison_pair, ~axis)) +
labs(
x = "Lag",
y = "Window start",
title = "Autocorrelation by lag and window start"
)
xcor_results <- do.call(bind_rows, xcor_results)
View(xcor_results)
# plot a heatmap for each condition, marker, axis
xcor_results %>%
ggplot(aes(x = lagv, y = window_start, fill = acfv)) +
geom_tile() +
scale_fill_distiller(palette = "Spectral") +
theme_minimal() +
facet_wrap(c(~comparison_pair, ~axis)) +
labs(
x = "Lag",
y = "Window start",
title = "Autocorrelation by lag and window start"
)
sel_pair <- 1
#set window size
window_size <- 600
max_lag <- 150
step_size <- 300
axes_of_interest = c("x", "y", "z")
axis <- "x"
# Initialize a list to store results across all windows
xcor_results <- list()
axis_data <- data %>%
ungroup() %>%
dplyr:: select(subject, !!sym(axis))
subjA <- axis_data %>% filter(subject == "Lead") %>% pull(!!sym(axis))
subjB <- axis_data %>% filter(subject == "Follow") %>% pull(!!sym(axis))
rowcount <- length(subjA)
for (window_start in seq(1, rowcount - window_size, step_size)) {
window_end <- window_start + window_size - 1
if (window_end > rowcount) {
window_end <- rowcount
}
results <- NULL
#function that runs cross correlation
results <- ccf(
x = subjA[window_start:window_end],
y = subjB[window_start:window_end],
na.action = na.omit,
plot = FALSE,
lag.max = max_lag
)
results <- tibble(
lagv = results$lag,
acfv = results$acf,
comparison_pair = sel_pair,
axis = axis,
window_start = window_start,
window_end = window_end
)
xcor_results[[length(xcor_results) + 1]] <- results
}
# Combine all results into a single tibble
xcor_results <- bind_rows(xcor_results)
# plot a heatmap for each condition, marker, axis
xcor_results %>%
ggplot(aes(x = lagv, y = window_start, fill = acfv)) +
geom_tile() +
scale_fill_distiller(palette = "Spectral") +
theme_minimal() +
facet_wrap(c(~comparison_pair, ~axis)) +
labs(
x = "Lag",
y = "Window start",
title = "Autocorrelation by lag and window start"
)
# save the plot
#ggsave(
#  filename = "./autocorrelation_by_lag_and_window_start.png",
#  width = 10,
#  height = 10,
# units = "cm",
#  dpi = 300
#)
# consider changing the axes to seconds instead of samples
#consider adding more axes and maybe more comparison pairs
sel_pairs <- 1
original_sample_rate <- 300
decimate_factor <- 6
window_size_samples <- 50
#downsampling
resampled_traj_data <- selected_traj_data %>%
group_by(subject, marker) %>%
dplyr::filter(
index %% decimate_factor == 0
) %>%
ungroup
resampled_traj_data <- resampled_traj_data %>%
group_by(subject, comp_pair_id) %>%
mutate_at(
vars(x, y, z),
~ scale(.)
) %>%
ungroup()
result <- dtw(
x = data[resampled_traj_data$subject == "Lead", "x"],
y = data[resampled_traj_data$subject == "Follow", "x"],
window.type = "sakoechiba",
window.size = window_size_samples,
keep = TRUE
)
result <- dtw(
x = data[resampled_traj_data$subject == "Lead", "x"],
y = data[resampled_traj_data$subject == "Follow", "x"],
window.type = "sakoechiba",
window.size = window_size_samples,
keep = TRUE
)
result <- dtw(
x = resampled_traj_data[resampled_traj_data$subject == "Lead", "x"],
y = resampled_traj_data[resampled_traj_data$subject == "Follow", "x"],
window.type = "sakoechiba",
window.size = window_size_samples,
keep = TRUE
)
result <- dtw(
x = resampled_traj_data[resampled_traj_data$subject == "Lead", "x"],
y = resampled_traj_data[resampled_traj_data$subject == "Follow", "x"],
window.type = "sakoechiba",
window.size = window_size_samples,
keep = TRUE
)
result
result
setwd("~/Cognitive_Science/Bachelor/Bachelor2025")
source("r_scripts/main.r")
setwd("~/Cognitive_Science/Bachelor/Bachelor2025/experiment_folder")
source("r_scripts/main.r")
